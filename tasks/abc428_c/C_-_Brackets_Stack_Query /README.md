## URL
https://atcoder.jp/contests/abc428/tasks/abc428_c
配点 : 300 点

## 問題
文字列 T が次の条件を満たすとき、T を良い括弧列と呼びます。
・次の操作を 0 回以上繰り返すことで T を空文字列にすることができる。
  ・T に(連続な)部分文字列として含まれる () を選び、これを取り除く。
例えば () や (()())、および空文字列は良い括弧列ですが、)()( や ))) は良い括弧列ではありません。
文字列 S があります。S ははじめ空文字列です。
以下で説明されるクエリを与えられる順に Q 個処理してください。そして、各クエリの直後に S が良い括弧列であるかを判定してください。
クエリは次の 2 種類です。
・1 c: 文字 c が与えられる。c は ( または ) である。c を S の末尾に追加する。
・2: S の末尾の文字を削除する。この時、S は空文字列でないことが保証される。

## 制約
1 ≤ Q ≤ 8 × 10^5
1 種類目のクエリの c は ( または )
2 種類目のクエリを与えられた時点で S は空でないことが保証される
Q は整数
実行時間制限：3sec

## 入力
入力は以下の形式で標準入力から与えられる。ここで query_i は i 番目のクエリを意味する。
Q
query_1
query_2
⋮
query_Q
各クエリは以下の 2 種類のいずれかの形式で与えられる。
1 c
2

## 出力
Q 行出力せよ。i 行目には、i 番目のクエリを処理した直後の文字列 S が良い括弧列である場合は Yes を、そうでない場合は No を出力せよ。

入力例 1
8
1 (
2
1 (
1 )
2
1 (
1 )
1 )

出力例 1
No
Yes
No
Yes
No
No
No
Yes

1 番目のクエリを処理した直後の S は "(" で、これは良い括弧列ではありません。
2 番目のクエリを処理した直後の S は空文字列で、これは良い括弧列です。
3 番目のクエリを処理した直後の S は "(" で、これは良い括弧列ではありません。
4 番目のクエリを処理した直後の S は "()" で、これは良い括弧列です。
5 番目のクエリを処理した直後の S は "(" で、これは良い括弧列ではありません。
6 番目のクエリを処理した直後の S は "((" で、これは良い括弧列ではありません。
7 番目のクエリを処理した直後の S は "(()" で、これは良い括弧列ではありません。
8 番目のクエリを処理した直後の S は "(())" で、これは良い括弧列です。

## メモ

まずは小さく考える。

### case1

#### 入力
1
1 (

#### 出力
No

#### 思考



### case2

#### 入力
1
1 )

#### 出力
No


#### 思考
最初に「)」が来ると、削除されない限りYesになる
あぁ、数を数えればいいのか・・？
例えば「((()))」これは・・・
あぁ、「（」のとき+1して「)」のとき-1して、結果が0になった時、その文字列は「Yes」じゃないか？
あぁでも、「)（」でも０になってしまうから、-1になった時点で「No」が確定するのか。
一旦ここまでをコードにしてみると、計算量はどうなる？
最終的な文字列の長さが最大で8×10 ^5でなんだから、問題なさそうではある。
　⇒んなわけない！1 + 2 + ... + 8*10^5≒16*10^10≒6*10^11は完全にタイムアウトだろう
なので、一回一回計算するのではなく、常に計算結果を持っておく必要がある。
また、数字だけでは、-1 + 1されたときNoなのに0だからYesということになってしまうので、別個で保持していないといけない
　⇒初めて[-1]になったときのindexを持っておけばいいのでは・・？
一旦これで実装してみよう


#####　一回目の提出

popのときのカウンター処理が入っていなかった。
lengthなんていうAttributeはなかった・・・

```python

Q = int(input())

# "("のときに+1, ")"のときに-1される
# negarive_indexがNoneのときに0ならYes,それ以外ならNo
counter = 0
# -1になった時のindex
negative_index = None
# 現在の文字リストを保持
stack = []
for i in range(Q):
    query = input().split()
    if query[0] == "1":
        stack.append(query[1])
        if query[1] == "(":
            counter += 1
            if negative_index is not None and counter == 0:
                negative_index = None
        else:
            counter -= 1
            if counter == -1:
                # -1になった瞬間だけnegative_indexで記憶する
                negative_index = stack.length() - 1
    elif query[0] == "2":
        stack.pop()
    
    print(negative_index, counter)

    # 返す条件を指定していく
    if negative_index is None and counter == 0:
        print("Yes")
    else:
        print("No")

```