# Step 0: 入出力まわり（高速化のため）
import sys
input = sys.stdin.readline

# Step 1: N, W を読む
N, W = map(int, input().split())

# Step 2: w[i], v[i] を 1-indexed で用意して読み込む
# 先頭にダミー0を置いて、C++版と同じ i=1..N の添字で扱えるようにする
w = [0] * (N + 1)
v = [0] * (N + 1)
for i in range(1, N + 1):
    wi, vi = map(int, input().split())
    w[i] = wi
    v[i] = vi

# Step 3: dp 配列を用意（(N+1) 行 × (W+1) 列）
# dp[i][j] = 先頭 i 個から重さちょうど j を作るときの価値の最大
# 到達不可能な状態は「十分小さい負の数」で埋める（-∞の代用）
NEG_INF = -10**18
dp = [[NEG_INF] * (W + 1) for _ in range(N + 1)]

# Step 4: 初期化（C++の dp[0][0]=0, dp[0][j>0]=-∞ に対応）
dp[0][0] = 0

# Step 5: 動的計画法（C++の2重ループをそのまま移植）
for i in range(1, N + 1):
    for j in range(0, W + 1):
        if j < w[i]:
            # 方法B（使う）は入りきらないので不可。方法Aのみ。
            dp[i][j] = dp[i - 1][j]
        else:
            # 使わない / 使う の最大
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])

# Step 6: 答え（重さ≦Wで到達可能な最大値：C++の for で max を取っているのに対応）
Answer = max(dp[N])  # dp[N][0..W] の最大
print(Answer)






# ---過去のメモ等


# 1 N(品物数) W(重さ)を受け取る

# 未知のものは何か？
    # 重さWを超えないようにN個の品物からいくつか選ぶとき、その品物の価値の合計の最大値の求め方
        # 
# 与えられているものは何か？
    # N 個の品物があり、品物には 1, 2, ..., N の番号が付いている
    # 品物 i (1 ≤ i ≤ N) の重さは w_i、価値は v_i 
    # 重さWを達成するmaxValueは複数のパターンがある可能性がある
# 条件は何か？
    # 品物の重複はできない


# 方針
# W=xまでのmaxValueを動的計画法で計算していけばいい?
# Wに達するまでの計算パターンを先に割り出した方がいい？
# 重さwを達成するmaxValueは複数のパターンがある可能性がある
# 例：[[1,1],[1,1],[2,2],[3,4]]のとき
    # dp(1)は[[1,1],[1,1]]の二パターンがありうる
    # dp(2)は[[[1,1],[1,1]], [2,2]]の二パターンがありうる ※ 一つ目は[dp(1)[0], dp(1)[1]] と書ける
    # dp(3)は[[3,4]]だけ。これはdp(2)の結果を用いない
# 要するに、下記の考慮が必要
    # Wが何の足し算で構成されているのか？　例:3なら[1+2=3, 1+1+1=3, 3=3]
    # dp(W)の構成する品物番号がないといけない(dictになる？) 理由：dp(1)+dp(2)をするとき同じ商品を足すことはできないので
        # 例：[[1,1],[1,1]]＋[2,2]はできるけど、[[1,1],[1,1]]＋[[1,1],[1,1]]は出来ない
    # 


# N = int(input())
# W = int(input())

# vals = {}

# count = 0
# while count < N:
#     # countをキーとして、valをvalueとしてdictに追加する
#     val = list(map(int, input().split()))
#     vals[count] = val
#     count += 1

# print(vals)


# ここまで1時間かけたがこれ以上難しそうだったので、教科書を読む

# ---

# 二次元配列を用いた動的計画法を考えましょう
# dp[i][j]：品物iまでの中から、重さの合計がjとなるように選んだ時の価値の最大値

# ここまでのヒントを基に再度考えてみる　2025/10/26 13:20

# 未知のものは何か？
    # 重さWを超えないようにN個の品物からいくつか選ぶとき、その品物の価値の合計の最大値の求め方
        # 
# 与えられているものは何か？
    # N 個の品物があり、品物には 1, 2, ..., N の番号が付いている
    # 品物 i (1 ≤ i ≤ N) の重さは w_i、価値は v_i 
    # 重さWを達成するmaxValueは複数のパターンがある可能性がある
    # 二次元配列を用いた動的計画法を考えましょう
    # dp[i][j]：品物iまでの中から、重さの合計がjとなるように選んだ時の価値の最大値を用いる
# 条件は何か？
    # 品物の重複はできない
